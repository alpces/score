<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App Master - Sistema de Pontuação</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
        import { getFirestore, collection, getDocs, setDoc, doc, deleteDoc } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';
        import { getDatabase, ref, set, remove, onValue, update } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyBudmIz5XvRzhlOfj0wHI0W5EIles3wsmY",
            authDomain: "contador-de-pontos-321ee.firebaseapp.com",
            projectId: "contador-de-pontos-321ee",
            storageBucket: "contador-de-pontos-321ee.firebasestorage.app",
            messagingSenderId: "817191889469",
            appId: "1:817191889469:web:cfb88023612f6b37491854",
            databaseURL: "https://contador-de-pontos-321ee-default-rtdb.europe-west1.firebasedatabase.app"
        };

        const app = initializeApp(firebaseConfig);
        window.db = getFirestore(app);
        window.rtdb = getDatabase(app);
        window.fbModules = { collection, getDocs, setDoc, doc, deleteDoc, ref, set, remove, onValue, update };
        window.dispatchEvent(new Event('firebaseReady'));
    </script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script>
        const CLIENT_URL = 'https://alpces.github.io/score/client.html';

        const playBuzzer = () => {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(650, audioContext.currentTime + 0.3);
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.6);
            oscillator.frequency.setValueAtTime(650, audioContext.currentTime + 0.9);
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 1.2);
            oscillator.frequency.setValueAtTime(650, audioContext.currentTime + 1.5);
            
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime + 1.8);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 2);
        };

        window.addEventListener('firebaseReady', () => {
            const { useState, useEffect, createElement: h } = React;
            const { db, rtdb, fbModules } = window;
            const { collection, getDocs, setDoc, doc, deleteDoc, ref, set, remove, onValue, update } = fbModules;

            function App() {
                const [setupComplete, setSetupComplete] = useState(false);
                const [numTables, setNumTables] = useState(0);
                const [initialScore, setInitialScore] = useState(1);
                const [buzzerText, setBuzzerText] = useState('BUZZER');
                const [blockBuzzerAtZero, setBlockBuzzerAtZero] = useState(true);
                const [tables, setTables] = useState([]);
                const [categories, setCategories] = useState([]);
                const [yellowCategory, setYellowCategory] = useState(null);
                const [redCategory, setRedCategory] = useState(null);
                const [usedCategories, setUsedCategories] = useState([]);
                const [showLeaderboard, setShowLeaderboard] = useState(false);
                const [leaderboardRevealPosition, setLeaderboardRevealPosition] = useState(null);
                const [tempNames, setTempNames] = useState({});
                const [tempCategories, setTempCategories] = useState(['']);
                const [predefinedCategories, setPredefinedCategories] = useState([]);
                const [showPredefined, setShowPredefined] = useState(false);
                const [showScores, setShowScores] = useState(false);
                const [flashEffects, setFlashEffects] = useState({});
                const [sessionId, setSessionId] = useState(null);
                const [codeCopied, setCodeCopied] = useState(false);
                const [connectedClients, setConnectedClients] = useState({});
                const [buzzers, setBuzzers] = useState({});
                const [showSessionCode, setShowSessionCode] = useState(true);
                const [showQRCode, setShowQRCode] = useState(false);
                const [showHistory, setShowHistory] = useState(false);
                const [sessionHistory, setSessionHistory] = useState([]);
                const [selectedHistoryEntry, setSelectedHistoryEntry] = useState(null);
                const [showSaveModal, setShowSaveModal] = useState(false);
                const [saveDescription, setSaveDescription] = useState('');

                useEffect(() => {
                    (async () => {
                        try {
                            const snap = await getDocs(collection(db, 'categories'));
                            const cats = [];
                            snap.forEach(d => cats.push(d.data().name));
                            setPredefinedCategories(cats.sort());
                        } catch (e) { console.error(e); }
                    })();
                }, []);

                useEffect(() => {
                    if (!showHistory) return;
                    const historyRef = ref(rtdb, 'sessionHistory');
                    const unsubHistory = onValue(historyRef, (snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            const history = Object.keys(data).map(key => ({
                                id: key,
                                ...data[key]
                            }));
                            history.sort((a, b) => b.timestamp - a.timestamp);
                            setSessionHistory(history);
                        } else {
                            setSessionHistory([]);
                        }
                    });
                    return () => unsubHistory();
                }, [showHistory]);

                useEffect(() => {
                    if (!setupComplete || !sessionId) return;

                    const clientsRef = ref(rtdb, `sessions/${sessionId}/clients`);
                    const buzzersRef = ref(rtdb, `sessions/${sessionId}/buzzers`);

                    const unsubClients = onValue(clientsRef, (snapshot) => {
                        const data = snapshot.val() || {};
                        setConnectedClients(data);
                        
                        if (numTables === 0) {
                            const newTables = Object.values(data).map(client => ({
                                id: client.tableNumber,
                                name: client.teamName || '',
                                score: initialScore
                            }));
                            setTables(prev => {
                                const merged = [...prev];
                                newTables.forEach(nt => {
                                    if (!merged.find(t => t.id === nt.id)) {
                                        merged.push(nt);
                                    }
                                });
                                return merged.sort((a, b) => a.id - b.id);
                            });
                        } else {
                            setTables(prev => prev.map(t => {
                                const client = Object.values(data).find(c => c.tableNumber === t.id);
                                return client ? { ...t, name: client.teamName || t.name } : t;
                            }));
                        }
                    });

                    const unsubBuzzers = onValue(buzzersRef, (snapshot) => {
                        const data = snapshot.val() || {};
                        const prevBuzzers = { ...buzzers };
                        setBuzzers(data);
                        
                        Object.keys(data).forEach(key => {
                            if (data[key].pressed && !prevBuzzers[key]?.pressed) {
                                playBuzzer();
                            }
                        });
                    });

                    return () => {
                        unsubClients();
                        unsubBuzzers();
                    };
                }, [setupComplete, sessionId]);

                const saveCats = async (cats) => {
                    try {
                        const snap = await getDocs(collection(db, 'categories'));
                        await Promise.all(snap.docs.map(d => deleteDoc(doc(db, 'categories', d.id))));
                        await Promise.all(cats.map((cat, i) => setDoc(doc(db, 'categories', `cat_${i}`), { name: cat })));
                        setPredefinedCategories(cats);
                    } catch (e) { 
                        console.error('Erro ao guardar categorias:', e); 
                    }
                };

                const syncGame = async () => {
                    if (!sessionId) return;
                    try {
                        await set(ref(rtdb, `sessions/${sessionId}/gameState`), {
                            tables: tables.map(t => ({ id: t.id, name: t.name, score: t.score })),
                            yellowCategory, redCategory, categories, active: true, 
                            buzzerText, blockBuzzerAtZero, timestamp: Date.now()
                        });
                    } catch (e) { console.error(e); }
                };

                useEffect(() => { if (setupComplete && sessionId) syncGame(); }, [tables, yellowCategory, redCategory]);

                const initGame = () => {
                    if (numTables > 0) {
                        setTables(Array.from({ length: numTables }, (_, i) => ({ 
                            id: i + 1, 
                            name: tempNames[i + 1] || '', 
                            score: initialScore 
                        })));
                    }
                    setCategories(tempCategories.filter(c => c.trim()));
                    setSessionId(Math.random().toString(36).substring(2, 8).toUpperCase());
                    setSetupComplete(true);
                };

                const updateScore = (id, change) => {
                    setTables(prev => prev.map(t => t.id === id ? { ...t, score: Math.max(0, t.score + change) } : t));
                    const txt = change > 0 ? `+${change}` : `${change}`;
                    setFlashEffects(p => ({ ...p, [id]: txt }));
                    setTimeout(() => setFlashEffects(p => { const u = { ...p }; delete u[id]; return u; }), 1000);
                };

                const changeCategory = (setter, current) => {
                    const avail = categories.filter(c => !usedCategories.includes(c) && c !== current);
                    if (!avail.length) return;
                    const cat = avail[Math.floor(Math.random() * avail.length)];
                    setUsedCategories([...usedCategories, cat]);
                    setter(cat);
                };

                const resetBuzzer = async (tableId) => {
                    if (!sessionId) return;
                    try {
                        await update(ref(rtdb, `sessions/${sessionId}/buzzers/${tableId}`), {
                            pressed: false,
                            timestamp: null,
                            enabled: true
                        });
                    } catch (e) { console.error(e); }
                };

                const resetAllBuzzers = async () => {
                    if (!sessionId) return;
                    try {
                        const updates = {};
                        Object.keys(buzzers).forEach(key => {
                            updates[`${key}/pressed`] = false;
                            updates[`${key}/timestamp`] = null;
                            updates[`${key}/enabled`] = true;
                        });
                        await update(ref(rtdb, `sessions/${sessionId}/buzzers`), updates);
                    } catch (e) { console.error(e); }
                };

                const saveSession = async (description = '') => {
                    if (!sessionId) return;
                    try {
                        const historyData = {
                            sessionId: sessionId,
                            timestamp: Date.now(),
                            description: description,
                            tables: tables.map(t => ({
                                id: t.id,
                                name: t.name,
                                score: t.score
                            })),
                            categories: categories,
                            yellowCategory: yellowCategory,
                            redCategory: redCategory,
                            usedCategories: usedCategories,
                            emails: {}
                        };

                        Object.values(connectedClients).forEach(client => {
                            historyData.emails[client.tableNumber] = client.emails || [];
                        });

                        const historyId = Math.random().toString(36).substring(2, 12);
                        await set(ref(rtdb, `sessionHistory/${historyId}`), historyData);
                        setShowSaveModal(false);
                        setSaveDescription('');
                        alert('Sessão gravada com sucesso!');
                    } catch (e) { 
                        console.error(e);
                        alert('Erro ao gravar sessão');
                    }
                };

                const loadSession = async (entry) => {
                    setTables(entry.tables);
                    setCategories(entry.categories || []);
                    setYellowCategory(entry.yellowCategory || null);
                    setRedCategory(entry.redCategory || null);
                    setUsedCategories(entry.usedCategories || []);
                    setSessionId(entry.sessionId);
                    setSetupComplete(true);
                    setShowHistory(false);
                    setSelectedHistoryEntry(null);
                    
                    // Reset all buzzers
                    try {
                        const buzzersRef = ref(rtdb, `sessions/${entry.sessionId}/buzzers`);
                        await set(buzzersRef, {});
                    } catch (e) { console.error(e); }
                };

                const resetGame = async () => {
                    if (!confirm('Tem a certeza que deseja iniciar uma nova sessão?')) return;
                    
                    const saveChoice = confirm('Deseja gravar a sessão atual antes de iniciar uma nova?');
                    if (saveChoice) {
                        setShowSaveModal(true);
                        return;
                    }

                    if (sessionId) try { await remove(ref(rtdb, `sessions/${sessionId}`)); } catch (e) {}
                    setSetupComplete(false); setTables([]); setCategories([]); setYellowCategory(null); setRedCategory(null);
                    setUsedCategories([]); setTempNames({}); setTempCategories(['']); setInitialScore(1); setNumTables(0);
                    setShowLeaderboard(false); setLeaderboardRevealPosition(null); setShowScores(false);
                    setFlashEffects({}); setSessionId(null); setCodeCopied(false); setConnectedClients({}); setBuzzers({});
                    setShowSessionCode(true); setBuzzerText('BUZZER'); setBlockBuzzerAtZero(true); setShowQRCode(false);
                };

                const proceedWithReset = async () => {
                    await saveSession(saveDescription);
                    if (sessionId) try { await remove(ref(rtdb, `sessions/${sessionId}`)); } catch (e) {}
                    setSetupComplete(false); setTables([]); setCategories([]); setYellowCategory(null); setRedCategory(null);
                    setUsedCategories([]); setTempNames({}); setTempCategories(['']); setInitialScore(1); setNumTables(0);
                    setShowLeaderboard(false); setLeaderboardRevealPosition(null); setShowScores(false);
                    setFlashEffects({}); setSessionId(null); setCodeCopied(false); setConnectedClients({}); setBuzzers({});
                    setShowSessionCode(true); setBuzzerText('BUZZER'); setBlockBuzzerAtZero(true); setShowQRCode(false);
                };

                const resetAllScores = () => {
                    if (!confirm('Tem a certeza que deseja resetar todas as pontuações?')) return;
                    
                    const saveChoice = confirm('Deseja gravar a sessão atual antes de resetar?');
                    if (saveChoice) {
                        setShowSaveModal(true);
                        return;
                    }

                    setTables(prev => prev.map(t => ({ ...t, score: initialScore })));
                };

                const proceedWithScoreReset = async () => {
                    await saveSession(saveDescription);
                    setTables(prev => prev.map(t => ({ ...t, score: initialScore })));
                };

                const deleteHistoryEntry = async (entryId) => {
                    if (!confirm('Tem a certeza que deseja eliminar este registo?')) return;
                    try {
                        await remove(ref(rtdb, `sessionHistory/${entryId}`));
                        setSessionHistory(sessionHistory.filter(h => h.id !== entryId));
                    } catch (e) { console.error(e); }
                };

                const generateQRCodeUrl = () => {
                    const url = `${CLIENT_URL}?session=${sessionId}`;
                    return `https://api.qrserver.com/v1/create-qr-code/?size=600x600&data=${encodeURIComponent(url)}`;
                };

                const sorted = () => [...tables].sort((a, b) => b.score - a.score);

                const getBuzzerOrder = () => {
                    return Object.entries(buzzers)
                        .filter(([_, b]) => b.pressed)
                        .sort((a, b) => a[1].timestamp - b[1].timestamp)
                        .map(([id, b], idx) => ({ tableId: parseInt(id), order: idx + 1, timestamp: b.timestamp }));
                };

                const formatDate = (timestamp) => {
                    const date = new Date(timestamp);
                    return date.toLocaleDateString('pt-PT') + ' ' + date.toLocaleTimeString('pt-PT', { hour: '2-digit', minute: '2-digit' });
                };

                if (showSaveModal) {
                    return h('div', { className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4' },
                        h('div', { className: 'bg-white rounded-2xl p-6 max-w-md w-full' },
                            h('h2', { className: 'text-xl font-bold mb-4' }, 'Gravar Sessão'),
                            h('div', { className: 'mb-4' },
                                h('label', { className: 'block text-sm font-semibold mb-2' }, 'Descrição (Opcional)'),
                                h('textarea', {
                                    value: saveDescription,
                                    onChange: (e) => setSaveDescription(e.target.value),
                                    placeholder: 'Adicione uma descrição para esta sessão...',
                                    className: 'w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-purple-500',
                                    rows: 4
                                })
                            ),
                            h('div', { className: 'flex gap-2' },
                                h('button', {
                                    onClick: () => { setShowSaveModal(false); setSaveDescription(''); },
                                    className: 'flex-1 px-4 py-2 bg-gray-300 text-gray-800 rounded-lg font-semibold hover:bg-gray-400'
                                }, 'Cancelar'),
                                h('button', {
                                    onClick: () => saveSession(saveDescription),
                                    className: 'flex-1 px-4 py-2 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700'
                                }, 'Gravar Sessão')
                            )
                        )
                    );
                }

                if (showHistory) {
                    if (selectedHistoryEntry) {
                        const entry = selectedHistoryEntry;
                        const sortedTables = [...entry.tables].sort((a, b) => a.id - b.id);
                        return h('div', { className: 'min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 p-3' },
                            h('div', { className: 'max-w-4xl mx-auto pt-4' },
                                h('div', { className: 'bg-white rounded-2xl p-4' },
                                    h('div', { className: 'flex justify-between mb-4' },
                                        h('div', null,
                                            h('h2', { className: 'text-xl font-bold' }, `Sessão ${entry.sessionId} - ${formatDate(entry.timestamp)}`),
                                            entry.description && h('p', { className: 'text-gray-600 mt-1' }, entry.description)
                                        ),
                                        h('button', { onClick: () => setSelectedHistoryEntry(null), className: 'px-3 py-1.5 bg-gray-600 text-white rounded hover:bg-gray-700' }, 'Voltar')
                                    ),
                                    h('button', {
                                        onClick: () => loadSession(entry),
                                        className: 'w-full bg-indigo-600 text-white py-2 rounded-lg font-bold hover:bg-indigo-700 mb-4'
                                    }, 'Carregar esta Sessão'),
                                    h('div', { className: 'space-y-3' },
                                        sortedTables.map(t => h('div', { key: t.id, className: 'bg-gray-50 p-4 rounded-lg' },
                                            h('div', { className: 'flex justify-between items-start mb-2' },
                                                h('div', null,
                                                    h('div', { className: 'font-bold text-lg text-gray-800' }, `Mesa ${t.id}`),
                                                    h('div', { className: 'text-sm text-gray-600' }, t.name)
                                                ),
                                                h('div', { className: 'text-2xl font-bold text-indigo-600' }, `${t.score} pts`)
                                            ),
                                            (entry.emails[t.id] && entry.emails[t.id].length > 0) && h('div', { className: 'mt-3 border-t pt-3' },
                                                h('div', { className: 'text-xs font-semibold text-gray-600 mb-2' }, 'E-mails:'),
                                                h('div', { className: 'space-y-1' },
                                                    entry.emails[t.id].map((email, idx) => h('div', { key: idx, className: 'text-sm text-gray-700' }, email))
                                                )
                                            )
                                        ))
                                    )
                                )
                            )
                        );
                    }

                    return h('div', { className: 'min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 p-3' },
                        h('div', { className: 'max-w-4xl mx-auto pt-4' },
                            h('div', { className: 'bg-white rounded-2xl p-4' },
                                h('div', { className: 'flex justify-between mb-4' },
                                    h('h2', { className: 'text-xl font-bold' }, 'Histórico de Sessões'),
                                    h('button', { onClick: () => setShowHistory(false), className: 'px-3 py-1.5 bg-gray-600 text-white rounded hover:bg-gray-700' }, 'Voltar')
                                ),
                                sessionHistory.length === 0
                                    ? h('p', { className: 'text-gray-600 text-center py-8' }, 'Nenhuma sessão gravada')
                                    : h('div', { className: 'space-y-2' },
                                        sessionHistory.map(entry => h('div', { key: entry.id, className: 'bg-gray-50 p-3 rounded-lg' },
                                            h('div', { className: 'flex justify-between items-start mb-2' },
                                                h('button', { 
                                                    onClick: () => setSelectedHistoryEntry(entry),
                                                    className: 'flex-1 text-left hover:bg-gray-100 p-2 rounded transition'
                                                }, h('div', null,
                                                    h('span', { className: 'font-semibold' }, `${entry.sessionId} - ${formatDate(entry.timestamp)}`),
                                                    entry.description && h('div', { className: 'text-xs text-gray-600 mt-1' }, entry.description)
                                                )),
                                                h('button', { 
                                                    onClick: () => deleteHistoryEntry(entry.id),
                                                    className: 'px-3 py-1 bg-red-500 text-white text-sm rounded hover:bg-red-600 ml-2'
                                                }, 'Apagar')
                                            )
                                        ))
                                    )
                            )
                        )
                    );
                }

                if (!setupComplete) {
                    return h('div', { className: 'min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 p-3 overflow-y-auto' },
                        h('div', { className: 'max-w-2xl mx-auto py-4' },
                            h('button', { 
                                onClick: () => setShowHistory(true),
                                className: 'w-full bg-blue-600 text-white py-2 rounded-lg font-bold hover:bg-blue-700 mb-4'
                            }, 'Histórico de Sessões'),
                            h('div', { className: 'bg-white rounded-2xl shadow-2xl p-4' },
                                h('h1', { className: 'text-2xl font-bold text-gray-800 text-center mb-4' }, 'Configuração do Jogo'),
                                h('div', { className: 'space-y-4' },
                                    h('div', null,
                                        h('label', { className: 'block text-sm font-semibold mb-2' }, 'Número de Mesas (0 = Dinâmico, máx: 20)'),
                                        h('input', { type: 'number', min: 0, max: 20, value: numTables, onChange: e => setNumTables(Math.min(20, Math.max(0, +e.target.value || 0))), className: 'w-full px-4 py-2 border-2 rounded-lg focus:border-indigo-500 outline-none' }),
                                        h('p', { className: 'text-xs text-gray-500 mt-1' }, 'Se 0, as mesas aparecem à medida que os clientes se conectam')
                                    ),
                                    h('div', null,
                                        h('label', { className: 'block text-sm font-semibold mb-2' }, 'Pontuação Inicial'),
                                        h('input', { type: 'number', min: 0, value: initialScore, onChange: e => setInitialScore(Math.max(0, +e.target.value || 0)), className: 'w-full px-4 py-2 border-2 rounded-lg focus:border-indigo-500 outline-none' })
                                    ),
                                    h('div', null,
                                        h('label', { className: 'block text-sm font-semibold mb-2' }, 'Texto do Botão Buzzer'),
                                        h('input', { type: 'text', value: buzzerText, onChange: e => setBuzzerText(e.target.value), placeholder: 'BUZZER', className: 'w-full px-4 py-2 border-2 rounded-lg focus:border-indigo-500 outline-none' })
                                    ),
                                    h('div', { className: 'flex items-center gap-2' },
                                        h('input', { type: 'checkbox', id: 'blockBuzzer', checked: blockBuzzerAtZero, onChange: e => setBlockBuzzerAtZero(e.target.checked), className: 'w-4 h-4' }),
                                        h('label', { htmlFor: 'blockBuzzer', className: 'text-sm font-semibold text-gray-700' }, 'Bloquear buzzer quando mesa tem 0 pontos')
                                    ),
                                    numTables > 0 && h('div', null,
                                        h('label', { className: 'block text-sm font-semibold mb-2' }, 'Nomes das Mesas'),
                                        h('div', { className: 'grid gap-2 max-h-48 overflow-y-auto' },
                                            Array.from({ length: numTables }, (_, i) => h('div', { key: i, className: 'flex gap-2' },
                                                h('span